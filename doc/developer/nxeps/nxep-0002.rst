==================================
NXEP 2 â€” API design of view slices
==================================

:Author: Mridul Seth
:Status: Draft
:Type: Standards Track
:Created: 2020-07-23


Abstract
--------

The core API of base classes in NetworkX uses (dict) views to expose
data about the graph's nodes and edges. In this NXEP we propose to
add slicing to Node(Data)View and Edge(Data)View.

Motivation and Scope
--------------------

While accessing Graph data with G.nodes and G.edges, the only way of slicing the data
is by casting the view to a list manually and then calling a slice on it.
A slice inherently implies an ordering of the elements. We intend to use the ordering
imposed on the nodes and edges by the iteration order (due to the adjacency data structure).

``G.nodes(data=True)`` returns a NodeDataView of all the nodes, ``G.nodes(data=True)[x]`` returns an attribute dictionary for the node x.
The current way of getting a slice out of the underlying dict view is to cast it to list and then
slice it ``list(G.nodes(data=True))[0:10]``. This bit of code is something that is written a lot of times
by users. For graphs with a lot of nodes and edges, ``G.nodes`` and ``G.edges`` will take a lot of screen space and
when the users try to slice the resulting view (the first instinct) it will error out. Users definitely need to go through
a couple of documentation links before they realise that they need to first cast this NodeDataView to a list and then create
a slice. Updating the documentation to make this more clear would be helpful.
But it also seems good to ease the complexity of this common idiom.

In this NXEP we propose to move the casting as list inside the Node(data)View methods.
Thus ``list(G.nodes(data=True))[0:10]`` either becomes ``G.nodes(data=True)[0:10]``
or it is provided by a new slicing method like ``G.nodes(data=True).slice(10)``
or a new slicing object to allow subscripting like ``G.nodes(data=True).slice[0:10:2]``.
Then users can get a small subset of nodes by creating a slice.

Usage and Impact
----------------

The main impact and the decision that needs to be taken in this NXEP is with
respect to the user facing API. By implementing this NXEP via subscripting NodeViews,
we may end up adding some ambiguity for users. As for example `G.nodes[x]`
will return an attribute dict but `G.nodes[0:5]` will return a list of first five nodes.
This will be more ambigious with EdgeView as ``G.edges[0, 1]`` will return an
attribute dictionary of the edge between 0 and 1 and ``G.edges[0:1]`` will return the first edge.
We need to find a way to counter this potential confusion.
The alternative proposal of a new slicing method is one possible solution.

For a historical context, in pre 2.0 NetworkX, G.nodes() and G.edges() returned lists.
So, slicing was native behavior like ``G.nodes()[:10]``. One caveat is that the order
of that list could change from one call to the next if the adjacency structure changed
between calls.

In more detail, in pre 2.0 NetworkX, there were 3 ways to access node information:
- ``G.node`` was a dict keyed by node to that node's attribute dict as a value.
- ``G.nodes()`` returned a list.
- ``G.nodes_iter()`` returned an iterator over the nodes.

In line with Python 3's move toward returning dict views and iterators rather than lists,
NetworkX 2.0 introduced a single interface for node information. ``G.nodes`` is a
dict-like object keyed by node to that node's attribute dict.
It also provides set-like operations on the nodes. And it offers a method ``G.nodes.data``
which provides an interface similar to ``dict.items`` but pulling out specific attributes
from the inner attribute dict rather than the entire dict. Functional synonyms
``G.nodes(data="cost", default=1)`` and ``G.nodes.data("cost", 1)`` allow an interface
that looks like a dict keyed by node to a specific node attribute.

Slicing was not provided in NetworkX 2.0 primarily because there was
no inherent order to the nodes or edges as stored in the
dict-of-dict-of-dict data structure. However, in Python 3.6, dicts
became ordered based on insertion order. So, nodes are ordered based
on when they were added to the graph and edges are ordered based on the
adjacency dict-of-dict structure. So, there is now a concept of the "first edge".

With this NXEP we would like to bring the intuitiveness
of slicing behavior back to ``G.edges`` and ``G.nodes`` using the node
add order and edge order based on adjacency storage.

On the computational front, if we create lists to allow slices, we use memory to store the lists.
This is something user would have anyway done with something like ``list(G.nodes(data=True))[0:10]``.
But we can do better with our slicing mechanisms.
We should be able to avoid constucting the entire list simply to get the slices by internally
using code like: ``indx=[n for i, n in enumerate(G.nodes(data=True)) if i in range(x.start, x.stop, s.step)]``
where x is the desired slice object.

Backward compatibility
----------------------

N/A

Detailed description
--------------------

The new implementation will let users slice Node(Data)View and Edge(Data)View.

The following code will be valid::

  >>> G.nodes(data=True)[0:10]
  >>> G.nodes[3:10]
  >>> G.edges[1:10]
  >>> G.edges(data=True)[4:6]

Prelimanary impelementation work is available at https://github.com/networkx/networkx/pull/4086

Alternatively, to get rid of the ambiguity in slicing API with respect to
the dict views we can implement a new
``slice`` method which leads to a less ambigious API.::

  >>> G.nodes(data=True).slice[:10]
  >>> G.nodes.slice[10:30]
  >>> G.edges.slice[10:40]
  >>> G.edges(data=True).slice[5:]


Related Work
------------

N/A


Implementation
--------------

The core of this NXEP is to implement ``slicing`` to Node(Data)View
and Edge(Data)View to allow users to access a subset of nodes and edges without casting them
first to a list. We will do this by adding a check of ``slice`` in the getitem dunder method of
Node(Data)View and Edge(Data)View and returning a list of the sliced values.

We can instead move the check for ``slice`` to an independent ``slice`` method for nodes and edges to
implement this NXEP.

Alternatives
------------

- Explicit documentation about casting to list
- To get rid of the API ambigiouity w.r.t ``__getitem__`` we can impelment a new method, something like ``G.nodes.head(x)`` (insipired by pandas) which return the first x nodes. [After discussion, this has been updated to using a ``slice`` object directly but interfacing it with an independent ``slice`` method of G.nodes and G.edges instead of implementing it in getitem dunder method]
- The nice colon syntax for slices is only available with subscript notation.
  To allow G.nodes.slice to use the nice colon syntax, we could make it a
  property that creates a subscriptable object. Syntax would be ``G.nodes.slice[4:9:2]``.


Discussion
----------

- https://github.com/networkx/networkx/pull/4086

